/*
  Given a string, find the length of the longest substring without repeating characters. For example, 
  the longest substring without repeating letters for "abcabcbb" is "abc", which the length is 3. For "bbbbb" the longest 
  substring is "b", with the length of 1.
*/

/*
  Trivial Solution: two pointers check one by one, accept but very slow.
*/

public class Solution {
    public int lengthOfLongestSubstring(String s) {
    	if(s==null || s.length()==0)
    		return 0;
    	
    	boolean[] used=new boolean[95]; // keep track of all the characters
    	int length=0; // the maximum length
    	int i;int j; // the two pointers
    	
    	used[s.charAt(0)-' ']=true;
    	length=1;
    	
    	for(i=0,j=i+1;j<s.length() && i<s.length();){
    		//System.out.println("i,j:"+i+" "+j);
    		if(i+1==j&& s.charAt(i)==s.charAt(j)){ // prepared for special case like "aaa"
    			i++;
    			j++;
    			continue;
    		}
    			
    		
    		char c=s.charAt(j); 
    		if(used[(int)(c-' ')] == true){ // the duplicate appears
    			String sub=s.substring(i,j);
    			if(sub.length()>length) //update length if necessary
    				length=sub.length();

    			for(int g=0;g<used.length;g++) // restore used
    				used[g]=false;
    			i=i+1;//i=j-1;
    			used[(int)(s.charAt(i)-' ')]=true; // first put  the first letter in 
				j=i+1;
    		}
    		else{
    			used[(int)(c-' ')]=true; // longer
    			j++;
    		}
    	}
    	if(s.substring(i,j).length()>length) // the last length may not get updated
    		length=s.substring(i,j).length();
    	return length;
    }
}

/*
	The right method to use, HashMap
*/
public class Solution {
    public int lengthOfLongestSubstring(String s) {
    	if(s==null || s.length()==0)
    		return 0;
    	// j in the front, i far left(more advanced)
    	Map<Character,Integer> map=new HashMap<Character, Integer>();//keep tracking the latest location of appearance of each letter
    	int max=0;
    	for(int i=0,j=0;i<s.length();i++){
    		if(map.containsKey(s.charAt(i))){ // duplicate found
    			j=Math.max(j, map.get(s.charAt(i))+1); 
    		}
    		map.put(s.charAt(i), i); // update location
    		max=Math.max(max, i-j+1); // update max
    	}
    	return max;
    }
}
//2015/10/19 Finish with Hashmap solution.

//2015/12/26: nail it with trivial solution:, but I think the above solution will be a little bit faster 
for(int i=0;i<s.length()-1;i++){
	int j=i+1;
	set.add(s.charAt(i));
	while(j<s.length()&&!set.contains(s.charAt(j))){
		set.add(s.charAt(j++));
	}
	max=Math.max(max, j-i);
	set.clear();
}
