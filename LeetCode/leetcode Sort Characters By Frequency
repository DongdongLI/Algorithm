/*
  Given a string, sort it in decreasing order based on the frequency of characters.

  Example 1:

  Input:
  "tree"

  Output:
  "eert"

  Explanation:
  'e' appears twice while 'r' and 't' both appear once.
  So 'e' must appear before both 'r' and 't'. Therefore "eetr" is also a valid answer.
  Example 2:

  Input:
  "cccaaa"

  Output:
  "cccaaa"

  Explanation:
  Both 'c' and 'a' appear three times, so "aaaccc" is also a valid answer.
  Note that "cacaca" is incorrect, as the same characters must be together.
  Example 3:

  Input:
  "Aabb"

  Output:
  "bbAa"

  Explanation:
  "bbaA" is also a valid answer, but "Aabb" is incorrect.
  Note that 'A' and 'a' are treated as two different characters.
*/

/*
  It is not that difficult. The difficult part is to remember how to use all the methods with priorityQueue
*/

public class Solution {
    public String frequencySort(String s) {
        if(s==null || s.length()==0)
            return s;
        
        Map<Character, Integer> map = new HashMap();
        
        char[] token = s.toCharArray();
        
        for(char c: token){
            if(!map.containsKey(c))
                map.put(c, 1);
            else
                map.put(c, map.get(c)+1);
        }
        
        PriorityQueue<Map.Entry<Character, Integer>> queue = new PriorityQueue(map.size(), 
             new Comparator<Map.Entry<Character, Integer>>(){
                public int compare(Map.Entry<Character, Integer> o1, Map.Entry<Character, Integer> o2){
                    return o2.getValue()-o1.getValue();
                 }
             });
        
        for(Map.Entry<Character, Integer> entry: map.entrySet() )
            queue.offer(entry);
        
        StringBuilder res = new StringBuilder();
        while(!queue.isEmpty()){
            Map.Entry<Character, Integer> entry = queue.poll();
            int time = entry.getValue();
            char c = entry.getKey();
            for(int i=0;i<time;i++)
                res.append(c);
        }
        return res.toString();
    }
}
/*
  The O(n) method:
  Still uses the map, but use a list to keep the times of appearance. use index
*/
class Solution {
    public String frequencySort(String s) {
        
        if(s == null || s.length()==0)return s;
        
        Map<Character, Integer> map = new HashMap<>();
        
        int max = 0;
        for(int i=0;i<s.length();i++){
            if(!map.containsKey(s.charAt(i))){
                map.put(s.charAt(i), 1);
            }
            else{
                map.put(s.charAt(i), map.get(s.charAt(i))+1);
            }
            max = Math.max(max, map.get(s.charAt(i)));
        }
        
        //put them in an Array
        List<Character>[] list = new List[max+1];
                
        for(Map.Entry<Character, Integer> entry: map.entrySet()){
            if(list[entry.getValue()] == null){
                list[entry.getValue()] = new ArrayList<Character>();
            }
            list[entry.getValue()].add(entry.getKey());
        }
        
        StringBuilder sb = new StringBuilder();
        for(int i=list.length-1;i>=1;i--){
            if(list[i] != null){
                for(Character c: list[i])
                    for(int j=0;j<i;j++)
                        sb.append(c);
            }
        }
        return sb.toString();
    }
}
