/*
Suppose a sorted array is rotated at some pivot unknown to you beforehand.

(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).

Find the minimum element.

You may assume no duplicate exists in the array.
*/

/*ideas
1.find out if it has been rotated or not by comparing the first and the last element
2.recursively search where is the pivot by binary search
*/
public class Solution {
    public int findMin(int[] num) {
        if(num.length==1)
			return num[0];
		
		int l=0;
		int r=num.length-1;
		if(num[l]<=num[r])
			return num[l];
		else
		while(l+1!=r)
		{
			int mid=(l+r)/2;
			if(num[mid]>num[l])
			{
				l=mid;
			}
			else if(num[mid]<num[l])
				r=mid;
				
		}
		return num[r];
	}
}
