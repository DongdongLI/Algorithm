/*
  Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered 
  from top to bottom.

  For example:
  Given the following binary tree,
     1            <---
   /   \
  2     3         <---
   \     \
    5     4       <---
  You should return [1, 3, 4].
*/

/*
    Trivial Solution:
      If look at a binary tree from the right side, we will see the last node of each level. So we traverse the nodes level by 
      level, and record the "val" of the last node of each level
*/

public class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res=new LinkedList<Integer>();
        if(root==null)
        	return res;
        //last row
        List<TreeNode> prev=new LinkedList<TreeNode>();
        List<TreeNode> curr=new LinkedList<TreeNode>();// this row
        
        prev.add(root);
        while(!prev.isEmpty()){
        	res.add(prev.get(prev.size()-1).val);
        	for(TreeNode node:prev){// send their children into the list
        		if(node.left!=null)
        			curr.add(node.left);
        		if(node.right!=null)
        			curr.add(node.right);
        	}
        	prev.clear();
        	prev.addAll(curr);
        	curr.clear();
        }
        return res;
    }
}
/*
  Yet another smart idea:
    1. Since we only take the last node of each row, so the size of the result set should be the same as the depth of the tree
    2. If let it goes down it self, the right path is among the longest path.
*/

public class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res=new LinkedList<Integer>();
        goDeeper(0, res, root);
        return res;
    }
    public void goDeeper(int depth, List<Integer> result,TreeNode node){
    	if(node==null)
    		return;
    	if(result.size()==depth){ // for example, at the beginning, there is nothing in "res", the node level is 0 as well
    		result.add(node.val);
    	}// it is important to explore the righ sub-tree here.
    	goDeeper(depth+1, result, node.right);
    	goDeeper(depth+1, result, node.left);
    }
}

//2016/1/9: totally forgot. need refresh
